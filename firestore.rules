
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  
    // Block everything by default
    match /{document=**} {
      allow read, write: if false;
    }

    // collective mood (public read, auth write)
    // This rule is permissive because the update logic within the transaction
    // is too complex to validate securely within Firestore rules.
    // This assumes the client-side transaction logic is trusted.
    match /appState/{docId} {
      allow read:  if true;
      allow write: if request.auth != null;
    }

    // snapshots (public read, auth create)
    match /moodSnapshots/{snapshotId} {
      allow read:   if true;
      allow create: if request.auth != null;
    }

    // per-user activity (auth-only, own-doc)
    match /userActivity/{userId} {
      allow read, write:
        if request.auth != null
        && request.auth.uid == userId;
    }

    // This rule uses a recursive wildcard {documents=**} to allow a user to
    // read/write to any document within their own mood history, including
    // documents in subcollections like 'dailySummaries'.
    match /userMoodHistory/{userId}/{documents=**} {
      allow read, write:
        if request.auth != null
        && request.auth.uid == userId;
    }

    // community thoughts
    match /communityQuotes/{quoteId} {
      // anyone can read
      allow read: if true;

      // create only if:
      //  • authenticated
      //  • text is a non-empty string <1000 chars
      //  • likes start at 0
      //  • submittedAt == now
      allow create: if request.auth != null
        && request.resource.data.text       is string
        && request.resource.data.text.size() > 0
        && request.resource.data.text.size() < 1000
        && request.resource.data.likes      == 0
        && request.resource.data.submittedAt == request.time;

      // update only for liking/unliking
      allow update: if request.auth != null
        // Ensure only 'likes' field is changed
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['likes'])
        // Ensure 'likes' is either incremented or decremented by 1
        && (request.resource.data.likes == resource.data.likes + 1 ||
            request.resource.data.likes == resource.data.likes - 1);
    }
  }
}
